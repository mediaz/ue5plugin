#include "../mzProtoCommon.h"
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ProtoCommon.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_ProtoCommon_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_ProtoCommon_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/any.pb.h>
#include <google/protobuf/descriptor.pb.h>
#include "Builtins.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_ProtoCommon_2eproto mzProto_API
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct mzProto_API TableStruct_ProtoCommon_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[6]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
mzProto_API extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_ProtoCommon_2eproto;
namespace mz {
namespace proto {
class Comment;
struct CommentDefaultTypeInternal;
mzProto_API extern CommentDefaultTypeInternal _Comment_default_instance_;
class Connection;
struct ConnectionDefaultTypeInternal;
mzProto_API extern ConnectionDefaultTypeInternal _Connection_default_instance_;
class Graph;
struct GraphDefaultTypeInternal;
mzProto_API extern GraphDefaultTypeInternal _Graph_default_instance_;
class Job;
struct JobDefaultTypeInternal;
mzProto_API extern JobDefaultTypeInternal _Job_default_instance_;
class Node;
struct NodeDefaultTypeInternal;
mzProto_API extern NodeDefaultTypeInternal _Node_default_instance_;
class Pin;
struct PinDefaultTypeInternal;
mzProto_API extern PinDefaultTypeInternal _Pin_default_instance_;
}  // namespace proto
}  // namespace mz
PROTOBUF_NAMESPACE_OPEN
template<> mzProto_API ::mz::proto::Comment* Arena::CreateMaybeMessage<::mz::proto::Comment>(Arena*);
template<> mzProto_API ::mz::proto::Connection* Arena::CreateMaybeMessage<::mz::proto::Connection>(Arena*);
template<> mzProto_API ::mz::proto::Graph* Arena::CreateMaybeMessage<::mz::proto::Graph>(Arena*);
template<> mzProto_API ::mz::proto::Job* Arena::CreateMaybeMessage<::mz::proto::Job>(Arena*);
template<> mzProto_API ::mz::proto::Node* Arena::CreateMaybeMessage<::mz::proto::Node>(Arena*);
template<> mzProto_API ::mz::proto::Pin* Arena::CreateMaybeMessage<::mz::proto::Pin>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace mz {
namespace proto {

enum JobType : int {
  CPU = 0,
  GPU_Pixel_Shader = 1,
  GPU_Compute_Shader = 2,
  GPU_CUDA = 3,
  JobType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  JobType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
mzProto_API bool JobType_IsValid(int value);
constexpr JobType JobType_MIN = CPU;
constexpr JobType JobType_MAX = GPU_CUDA;
constexpr int JobType_ARRAYSIZE = JobType_MAX + 1;

mzProto_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* JobType_descriptor();
template<typename T>
inline const std::string& JobType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, JobType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function JobType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    JobType_descriptor(), enum_t_value);
}
inline bool JobType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, JobType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<JobType>(
    JobType_descriptor(), name, value);
}
enum NodeType : int {
  Ref = 0,
  Job_Def = 1,
  Graph_Def = 2,
  NodeType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  NodeType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
mzProto_API bool NodeType_IsValid(int value);
constexpr NodeType NodeType_MIN = Ref;
constexpr NodeType NodeType_MAX = Graph_Def;
constexpr int NodeType_ARRAYSIZE = NodeType_MAX + 1;

mzProto_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* NodeType_descriptor();
template<typename T>
inline const std::string& NodeType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, NodeType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function NodeType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    NodeType_descriptor(), enum_t_value);
}
inline bool NodeType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, NodeType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<NodeType>(
    NodeType_descriptor(), name, value);
}
enum ShowAs : int {
  HIDDEN = 0,
  PROPERTY = 1,
  OUTPUT_PIN = 2,
  INPUT_PIN = 4,
  ShowAs_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ShowAs_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
mzProto_API bool ShowAs_IsValid(int value);
constexpr ShowAs ShowAs_MIN = HIDDEN;
constexpr ShowAs ShowAs_MAX = INPUT_PIN;
constexpr int ShowAs_ARRAYSIZE = ShowAs_MAX + 1;

mzProto_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ShowAs_descriptor();
template<typename T>
inline const std::string& ShowAs_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ShowAs>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ShowAs_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ShowAs_descriptor(), enum_t_value);
}
inline bool ShowAs_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ShowAs* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ShowAs>(
    ShowAs_descriptor(), name, value);
}
enum CanShowAs : int {
  NONE = 0,
  PROPERTY_ONLY = 1,
  OUTPUT_PIN_ONLY = 2,
  OUTPUT_PIN_OR_PROPERTY = 3,
  INPUT_PIN_ONLY = 4,
  INPUT_PIN_OR_PROPERTY = 5,
  CanShowAs_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CanShowAs_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
mzProto_API bool CanShowAs_IsValid(int value);
constexpr CanShowAs CanShowAs_MIN = NONE;
constexpr CanShowAs CanShowAs_MAX = INPUT_PIN_OR_PROPERTY;
constexpr int CanShowAs_ARRAYSIZE = CanShowAs_MAX + 1;

mzProto_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CanShowAs_descriptor();
template<typename T>
inline const std::string& CanShowAs_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CanShowAs>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CanShowAs_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CanShowAs_descriptor(), enum_t_value);
}
inline bool CanShowAs_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CanShowAs* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CanShowAs>(
    CanShowAs_descriptor(), name, value);
}
// ===================================================================

class mzProto_API Job final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mz.proto.Job) */ {
 public:
  inline Job() : Job(nullptr) {}
  ~Job() override;
  explicit constexpr Job(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Job(const Job& from);
  Job(Job&& from) noexcept
    : Job() {
    *this = ::std::move(from);
  }

  inline Job& operator=(const Job& from) {
    CopyFrom(from);
    return *this;
  }
  inline Job& operator=(Job&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Job& default_instance() {
    return *internal_default_instance();
  }
  static inline const Job* internal_default_instance() {
    return reinterpret_cast<const Job*>(
               &_Job_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Job& a, Job& b) {
    a.Swap(&b);
  }
  inline void Swap(Job* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Job* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Job* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Job>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Job& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Job& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Job* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mz.proto.Job";
  }
  protected:
  explicit Job(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // optional .google.protobuf.Any data = 1;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::PROTOBUF_NAMESPACE_ID::Any& data() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Any* release_data();
  ::PROTOBUF_NAMESPACE_ID::Any* mutable_data();
  void set_allocated_data(::PROTOBUF_NAMESPACE_ID::Any* data);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Any& _internal_data() const;
  ::PROTOBUF_NAMESPACE_ID::Any* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::PROTOBUF_NAMESPACE_ID::Any* data);
  ::PROTOBUF_NAMESPACE_ID::Any* unsafe_arena_release_data();

  // @@protoc_insertion_point(class_scope:mz.proto.Job)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::Any* data_;
  friend struct ::TableStruct_ProtoCommon_2eproto;
};
// -------------------------------------------------------------------

class mzProto_API Graph final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mz.proto.Graph) */ {
 public:
  inline Graph() : Graph(nullptr) {}
  ~Graph() override;
  explicit constexpr Graph(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Graph(const Graph& from);
  Graph(Graph&& from) noexcept
    : Graph() {
    *this = ::std::move(from);
  }

  inline Graph& operator=(const Graph& from) {
    CopyFrom(from);
    return *this;
  }
  inline Graph& operator=(Graph&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Graph& default_instance() {
    return *internal_default_instance();
  }
  static inline const Graph* internal_default_instance() {
    return reinterpret_cast<const Graph*>(
               &_Graph_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Graph& a, Graph& b) {
    a.Swap(&b);
  }
  inline void Swap(Graph* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Graph* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Graph* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Graph>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Graph& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Graph& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Graph* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mz.proto.Graph";
  }
  protected:
  explicit Graph(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodesFieldNumber = 1,
    kConnectionsFieldNumber = 2,
    kCommentsFieldNumber = 3,
  };
  // repeated .mz.proto.Node nodes = 1;
  int nodes_size() const;
  private:
  int _internal_nodes_size() const;
  public:
  void clear_nodes();
  ::mz::proto::Node* mutable_nodes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mz::proto::Node >*
      mutable_nodes();
  private:
  const ::mz::proto::Node& _internal_nodes(int index) const;
  ::mz::proto::Node* _internal_add_nodes();
  public:
  const ::mz::proto::Node& nodes(int index) const;
  ::mz::proto::Node* add_nodes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mz::proto::Node >&
      nodes() const;

  // repeated .mz.proto.Connection connections = 2;
  int connections_size() const;
  private:
  int _internal_connections_size() const;
  public:
  void clear_connections();
  ::mz::proto::Connection* mutable_connections(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mz::proto::Connection >*
      mutable_connections();
  private:
  const ::mz::proto::Connection& _internal_connections(int index) const;
  ::mz::proto::Connection* _internal_add_connections();
  public:
  const ::mz::proto::Connection& connections(int index) const;
  ::mz::proto::Connection* add_connections();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mz::proto::Connection >&
      connections() const;

  // repeated .mz.proto.Comment comments = 3;
  int comments_size() const;
  private:
  int _internal_comments_size() const;
  public:
  void clear_comments();
  ::mz::proto::Comment* mutable_comments(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mz::proto::Comment >*
      mutable_comments();
  private:
  const ::mz::proto::Comment& _internal_comments(int index) const;
  ::mz::proto::Comment* _internal_add_comments();
  public:
  const ::mz::proto::Comment& comments(int index) const;
  ::mz::proto::Comment* add_comments();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mz::proto::Comment >&
      comments() const;

  // @@protoc_insertion_point(class_scope:mz.proto.Graph)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mz::proto::Node > nodes_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mz::proto::Connection > connections_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mz::proto::Comment > comments_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ProtoCommon_2eproto;
};
// -------------------------------------------------------------------

class mzProto_API Comment final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mz.proto.Comment) */ {
 public:
  inline Comment() : Comment(nullptr) {}
  ~Comment() override;
  explicit constexpr Comment(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Comment(const Comment& from);
  Comment(Comment&& from) noexcept
    : Comment() {
    *this = ::std::move(from);
  }

  inline Comment& operator=(const Comment& from) {
    CopyFrom(from);
    return *this;
  }
  inline Comment& operator=(Comment&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Comment& default_instance() {
    return *internal_default_instance();
  }
  static inline const Comment* internal_default_instance() {
    return reinterpret_cast<const Comment*>(
               &_Comment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Comment& a, Comment& b) {
    a.Swap(&b);
  }
  inline void Swap(Comment* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Comment* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Comment* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Comment>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Comment& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Comment& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Comment* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mz.proto.Comment";
  }
  protected:
  explicit Comment(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kDisplayNameFieldNumber = 2,
    kPosFieldNumber = 3,
    kSizeFieldNumber = 4,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string display_name = 2;
  void clear_display_name();
  const std::string& display_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_display_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_display_name();
  PROTOBUF_NODISCARD std::string* release_display_name();
  void set_allocated_display_name(std::string* display_name);
  private:
  const std::string& _internal_display_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_display_name(const std::string& value);
  std::string* _internal_mutable_display_name();
  public:

  // .mz.proto.vec2i pos = 3;
  bool has_pos() const;
  private:
  bool _internal_has_pos() const;
  public:
  void clear_pos();
  const ::mz::proto::vec2i& pos() const;
  PROTOBUF_NODISCARD ::mz::proto::vec2i* release_pos();
  ::mz::proto::vec2i* mutable_pos();
  void set_allocated_pos(::mz::proto::vec2i* pos);
  private:
  const ::mz::proto::vec2i& _internal_pos() const;
  ::mz::proto::vec2i* _internal_mutable_pos();
  public:
  void unsafe_arena_set_allocated_pos(
      ::mz::proto::vec2i* pos);
  ::mz::proto::vec2i* unsafe_arena_release_pos();

  // .mz.proto.vec2i size = 4;
  bool has_size() const;
  private:
  bool _internal_has_size() const;
  public:
  void clear_size();
  const ::mz::proto::vec2i& size() const;
  PROTOBUF_NODISCARD ::mz::proto::vec2i* release_size();
  ::mz::proto::vec2i* mutable_size();
  void set_allocated_size(::mz::proto::vec2i* size);
  private:
  const ::mz::proto::vec2i& _internal_size() const;
  ::mz::proto::vec2i* _internal_mutable_size();
  public:
  void unsafe_arena_set_allocated_size(
      ::mz::proto::vec2i* size);
  ::mz::proto::vec2i* unsafe_arena_release_size();

  // @@protoc_insertion_point(class_scope:mz.proto.Comment)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr display_name_;
  ::mz::proto::vec2i* pos_;
  ::mz::proto::vec2i* size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ProtoCommon_2eproto;
};
// -------------------------------------------------------------------

class mzProto_API Pin final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mz.proto.Pin) */ {
 public:
  inline Pin() : Pin(nullptr) {}
  ~Pin() override;
  explicit constexpr Pin(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Pin(const Pin& from);
  Pin(Pin&& from) noexcept
    : Pin() {
    *this = ::std::move(from);
  }

  inline Pin& operator=(const Pin& from) {
    CopyFrom(from);
    return *this;
  }
  inline Pin& operator=(Pin&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Pin& default_instance() {
    return *internal_default_instance();
  }
  static inline const Pin* internal_default_instance() {
    return reinterpret_cast<const Pin*>(
               &_Pin_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Pin& a, Pin& b) {
    a.Swap(&b);
  }
  inline void Swap(Pin* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Pin* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Pin* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Pin>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Pin& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Pin& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Pin* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mz.proto.Pin";
  }
  protected:
  explicit Pin(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kDisplayNameFieldNumber = 3,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string display_name = 3;
  void clear_display_name();
  const std::string& display_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_display_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_display_name();
  PROTOBUF_NODISCARD std::string* release_display_name();
  void set_allocated_display_name(std::string* display_name);
  private:
  const std::string& _internal_display_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_display_name(const std::string& value);
  std::string* _internal_mutable_display_name();
  public:

  // @@protoc_insertion_point(class_scope:mz.proto.Pin)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr display_name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ProtoCommon_2eproto;
};
// -------------------------------------------------------------------

class mzProto_API Connection final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mz.proto.Connection) */ {
 public:
  inline Connection() : Connection(nullptr) {}
  ~Connection() override;
  explicit constexpr Connection(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Connection(const Connection& from);
  Connection(Connection&& from) noexcept
    : Connection() {
    *this = ::std::move(from);
  }

  inline Connection& operator=(const Connection& from) {
    CopyFrom(from);
    return *this;
  }
  inline Connection& operator=(Connection&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Connection& default_instance() {
    return *internal_default_instance();
  }
  static inline const Connection* internal_default_instance() {
    return reinterpret_cast<const Connection*>(
               &_Connection_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Connection& a, Connection& b) {
    a.Swap(&b);
  }
  inline void Swap(Connection* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Connection* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Connection* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Connection>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Connection& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Connection& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Connection* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mz.proto.Connection";
  }
  protected:
  explicit Connection(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFromFieldNumber = 1,
    kToFieldNumber = 2,
    kIdFieldNumber = 3,
  };
  // string from = 1;
  void clear_from();
  const std::string& from() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_from(ArgT0&& arg0, ArgT... args);
  std::string* mutable_from();
  PROTOBUF_NODISCARD std::string* release_from();
  void set_allocated_from(std::string* from);
  private:
  const std::string& _internal_from() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_from(const std::string& value);
  std::string* _internal_mutable_from();
  public:

  // string to = 2;
  void clear_to();
  const std::string& to() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_to(ArgT0&& arg0, ArgT... args);
  std::string* mutable_to();
  PROTOBUF_NODISCARD std::string* release_to();
  void set_allocated_to(std::string* to);
  private:
  const std::string& _internal_to() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_to(const std::string& value);
  std::string* _internal_mutable_to();
  public:

  // string id = 3;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:mz.proto.Connection)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr from_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr to_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ProtoCommon_2eproto;
};
// -------------------------------------------------------------------

class mzProto_API Node final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mz.proto.Node) */ {
 public:
  inline Node() : Node(nullptr) {}
  ~Node() override;
  explicit constexpr Node(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Node(const Node& from);
  Node(Node&& from) noexcept
    : Node() {
    *this = ::std::move(from);
  }

  inline Node& operator=(const Node& from) {
    CopyFrom(from);
    return *this;
  }
  inline Node& operator=(Node&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Node& default_instance() {
    return *internal_default_instance();
  }
  enum ContentsCase {
    kJob = 7,
    kGraph = 8,
    CONTENTS_NOT_SET = 0,
  };

  static inline const Node* internal_default_instance() {
    return reinterpret_cast<const Node*>(
               &_Node_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Node& a, Node& b) {
    a.Swap(&b);
  }
  inline void Swap(Node* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Node* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Node* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Node>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Node& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Node& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Node* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mz.proto.Node";
  }
  protected:
  explicit Node(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPinsFieldNumber = 5,
    kIdFieldNumber = 2,
    kClassNameFieldNumber = 3,
    kDisplayNameFieldNumber = 4,
    kPosFieldNumber = 6,
    kTypeFieldNumber = 1,
    kJobFieldNumber = 7,
    kGraphFieldNumber = 8,
  };
  // repeated .mz.proto.Pin pins = 5;
  int pins_size() const;
  private:
  int _internal_pins_size() const;
  public:
  void clear_pins();
  ::mz::proto::Pin* mutable_pins(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mz::proto::Pin >*
      mutable_pins();
  private:
  const ::mz::proto::Pin& _internal_pins(int index) const;
  ::mz::proto::Pin* _internal_add_pins();
  public:
  const ::mz::proto::Pin& pins(int index) const;
  ::mz::proto::Pin* add_pins();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mz::proto::Pin >&
      pins() const;

  // string id = 2;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string class_name = 3;
  void clear_class_name();
  const std::string& class_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_class_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_class_name();
  PROTOBUF_NODISCARD std::string* release_class_name();
  void set_allocated_class_name(std::string* class_name);
  private:
  const std::string& _internal_class_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_class_name(const std::string& value);
  std::string* _internal_mutable_class_name();
  public:

  // string display_name = 4;
  void clear_display_name();
  const std::string& display_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_display_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_display_name();
  PROTOBUF_NODISCARD std::string* release_display_name();
  void set_allocated_display_name(std::string* display_name);
  private:
  const std::string& _internal_display_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_display_name(const std::string& value);
  std::string* _internal_mutable_display_name();
  public:

  // .mz.proto.vec2i pos = 6;
  bool has_pos() const;
  private:
  bool _internal_has_pos() const;
  public:
  void clear_pos();
  const ::mz::proto::vec2i& pos() const;
  PROTOBUF_NODISCARD ::mz::proto::vec2i* release_pos();
  ::mz::proto::vec2i* mutable_pos();
  void set_allocated_pos(::mz::proto::vec2i* pos);
  private:
  const ::mz::proto::vec2i& _internal_pos() const;
  ::mz::proto::vec2i* _internal_mutable_pos();
  public:
  void unsafe_arena_set_allocated_pos(
      ::mz::proto::vec2i* pos);
  ::mz::proto::vec2i* unsafe_arena_release_pos();

  // .mz.proto.NodeType type = 1;
  void clear_type();
  ::mz::proto::NodeType type() const;
  void set_type(::mz::proto::NodeType value);
  private:
  ::mz::proto::NodeType _internal_type() const;
  void _internal_set_type(::mz::proto::NodeType value);
  public:

  // .mz.proto.Job job = 7;
  bool has_job() const;
  private:
  bool _internal_has_job() const;
  public:
  void clear_job();
  const ::mz::proto::Job& job() const;
  PROTOBUF_NODISCARD ::mz::proto::Job* release_job();
  ::mz::proto::Job* mutable_job();
  void set_allocated_job(::mz::proto::Job* job);
  private:
  const ::mz::proto::Job& _internal_job() const;
  ::mz::proto::Job* _internal_mutable_job();
  public:
  void unsafe_arena_set_allocated_job(
      ::mz::proto::Job* job);
  ::mz::proto::Job* unsafe_arena_release_job();

  // .mz.proto.Graph graph = 8;
  bool has_graph() const;
  private:
  bool _internal_has_graph() const;
  public:
  void clear_graph();
  const ::mz::proto::Graph& graph() const;
  PROTOBUF_NODISCARD ::mz::proto::Graph* release_graph();
  ::mz::proto::Graph* mutable_graph();
  void set_allocated_graph(::mz::proto::Graph* graph);
  private:
  const ::mz::proto::Graph& _internal_graph() const;
  ::mz::proto::Graph* _internal_mutable_graph();
  public:
  void unsafe_arena_set_allocated_graph(
      ::mz::proto::Graph* graph);
  ::mz::proto::Graph* unsafe_arena_release_graph();

  void clear_contents();
  ContentsCase contents_case() const;
  // @@protoc_insertion_point(class_scope:mz.proto.Node)
 private:
  class _Internal;
  void set_has_job();
  void set_has_graph();

  inline bool has_contents() const;
  inline void clear_has_contents();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mz::proto::Pin > pins_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr class_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr display_name_;
  ::mz::proto::vec2i* pos_;
  int type_;
  union ContentsUnion {
    constexpr ContentsUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::mz::proto::Job* job_;
    ::mz::proto::Graph* graph_;
  } contents_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_ProtoCommon_2eproto;
};
// ===================================================================

static const int kIndexFieldNumber = 7740941;
mzProto_API extern ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::PROTOBUF_NAMESPACE_ID::FieldOptions,
    ::PROTOBUF_NAMESPACE_ID::internal::PrimitiveTypeTraits< int32_t >, 5, false >
  index;
static const int kDisplayNameFieldNumber = 7740937;
mzProto_API extern ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::PROTOBUF_NAMESPACE_ID::FieldOptions,
    ::PROTOBUF_NAMESPACE_ID::internal::StringTypeTraits, 9, false >
  display_name;
static const int kShowAsFieldNumber = 7740938;
mzProto_API extern ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::PROTOBUF_NAMESPACE_ID::FieldOptions,
    ::PROTOBUF_NAMESPACE_ID::internal::EnumTypeTraits< ::mz::proto::ShowAs, ::mz::proto::ShowAs_IsValid>, 14, false >
  show_as;
static const int kCanShowAsFieldNumber = 7740939;
mzProto_API extern ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::PROTOBUF_NAMESPACE_ID::FieldOptions,
    ::PROTOBUF_NAMESPACE_ID::internal::EnumTypeTraits< ::mz::proto::CanShowAs, ::mz::proto::CanShowAs_IsValid>, 14, false >
  can_show_as;
static const int kTypeFieldNumber = 51234;
mzProto_API extern ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::PROTOBUF_NAMESPACE_ID::MessageOptions,
    ::PROTOBUF_NAMESPACE_ID::internal::EnumTypeTraits< ::mz::proto::JobType, ::mz::proto::JobType_IsValid>, 14, false >
  type;
static const int kSourceFileFieldNumber = 51235;
mzProto_API extern ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::PROTOBUF_NAMESPACE_ID::MessageOptions,
    ::PROTOBUF_NAMESPACE_ID::internal::StringTypeTraits, 9, false >
  source_file;
static const int kEntryPointFieldNumber = 51236;
mzProto_API extern ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::PROTOBUF_NAMESPACE_ID::MessageOptions,
    ::PROTOBUF_NAMESPACE_ID::internal::StringTypeTraits, 9, false >
  entry_point;

// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Job

// optional .google.protobuf.Any data = 1;
inline bool Job::_internal_has_data() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || data_ != nullptr);
  return value;
}
inline bool Job::has_data() const {
  return _internal_has_data();
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& Job::_internal_data() const {
  const ::PROTOBUF_NAMESPACE_ID::Any* p = data_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Any&>(
      ::PROTOBUF_NAMESPACE_ID::_Any_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& Job::data() const {
  // @@protoc_insertion_point(field_get:mz.proto.Job.data)
  return _internal_data();
}
inline void Job::unsafe_arena_set_allocated_data(
    ::PROTOBUF_NAMESPACE_ID::Any* data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data_);
  }
  data_ = data;
  if (data) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mz.proto.Job.data)
}
inline ::PROTOBUF_NAMESPACE_ID::Any* Job::release_data() {
  _has_bits_[0] &= ~0x00000001u;
  ::PROTOBUF_NAMESPACE_ID::Any* temp = data_;
  data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* Job::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:mz.proto.Job.data)
  _has_bits_[0] &= ~0x00000001u;
  ::PROTOBUF_NAMESPACE_ID::Any* temp = data_;
  data_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* Job::_internal_mutable_data() {
  _has_bits_[0] |= 0x00000001u;
  if (data_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Any>(GetArenaForAllocation());
    data_ = p;
  }
  return data_;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* Job::mutable_data() {
  ::PROTOBUF_NAMESPACE_ID::Any* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:mz.proto.Job.data)
  return _msg;
}
inline void Job::set_allocated_data(::PROTOBUF_NAMESPACE_ID::Any* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(data_);
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data));
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  data_ = data;
  // @@protoc_insertion_point(field_set_allocated:mz.proto.Job.data)
}

// -------------------------------------------------------------------

// Graph

// repeated .mz.proto.Node nodes = 1;
inline int Graph::_internal_nodes_size() const {
  return nodes_.size();
}
inline int Graph::nodes_size() const {
  return _internal_nodes_size();
}
inline void Graph::clear_nodes() {
  nodes_.Clear();
}
inline ::mz::proto::Node* Graph::mutable_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:mz.proto.Graph.nodes)
  return nodes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mz::proto::Node >*
Graph::mutable_nodes() {
  // @@protoc_insertion_point(field_mutable_list:mz.proto.Graph.nodes)
  return &nodes_;
}
inline const ::mz::proto::Node& Graph::_internal_nodes(int index) const {
  return nodes_.Get(index);
}
inline const ::mz::proto::Node& Graph::nodes(int index) const {
  // @@protoc_insertion_point(field_get:mz.proto.Graph.nodes)
  return _internal_nodes(index);
}
inline ::mz::proto::Node* Graph::_internal_add_nodes() {
  return nodes_.Add();
}
inline ::mz::proto::Node* Graph::add_nodes() {
  ::mz::proto::Node* _add = _internal_add_nodes();
  // @@protoc_insertion_point(field_add:mz.proto.Graph.nodes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mz::proto::Node >&
Graph::nodes() const {
  // @@protoc_insertion_point(field_list:mz.proto.Graph.nodes)
  return nodes_;
}

// repeated .mz.proto.Connection connections = 2;
inline int Graph::_internal_connections_size() const {
  return connections_.size();
}
inline int Graph::connections_size() const {
  return _internal_connections_size();
}
inline void Graph::clear_connections() {
  connections_.Clear();
}
inline ::mz::proto::Connection* Graph::mutable_connections(int index) {
  // @@protoc_insertion_point(field_mutable:mz.proto.Graph.connections)
  return connections_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mz::proto::Connection >*
Graph::mutable_connections() {
  // @@protoc_insertion_point(field_mutable_list:mz.proto.Graph.connections)
  return &connections_;
}
inline const ::mz::proto::Connection& Graph::_internal_connections(int index) const {
  return connections_.Get(index);
}
inline const ::mz::proto::Connection& Graph::connections(int index) const {
  // @@protoc_insertion_point(field_get:mz.proto.Graph.connections)
  return _internal_connections(index);
}
inline ::mz::proto::Connection* Graph::_internal_add_connections() {
  return connections_.Add();
}
inline ::mz::proto::Connection* Graph::add_connections() {
  ::mz::proto::Connection* _add = _internal_add_connections();
  // @@protoc_insertion_point(field_add:mz.proto.Graph.connections)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mz::proto::Connection >&
Graph::connections() const {
  // @@protoc_insertion_point(field_list:mz.proto.Graph.connections)
  return connections_;
}

// repeated .mz.proto.Comment comments = 3;
inline int Graph::_internal_comments_size() const {
  return comments_.size();
}
inline int Graph::comments_size() const {
  return _internal_comments_size();
}
inline void Graph::clear_comments() {
  comments_.Clear();
}
inline ::mz::proto::Comment* Graph::mutable_comments(int index) {
  // @@protoc_insertion_point(field_mutable:mz.proto.Graph.comments)
  return comments_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mz::proto::Comment >*
Graph::mutable_comments() {
  // @@protoc_insertion_point(field_mutable_list:mz.proto.Graph.comments)
  return &comments_;
}
inline const ::mz::proto::Comment& Graph::_internal_comments(int index) const {
  return comments_.Get(index);
}
inline const ::mz::proto::Comment& Graph::comments(int index) const {
  // @@protoc_insertion_point(field_get:mz.proto.Graph.comments)
  return _internal_comments(index);
}
inline ::mz::proto::Comment* Graph::_internal_add_comments() {
  return comments_.Add();
}
inline ::mz::proto::Comment* Graph::add_comments() {
  ::mz::proto::Comment* _add = _internal_add_comments();
  // @@protoc_insertion_point(field_add:mz.proto.Graph.comments)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mz::proto::Comment >&
Graph::comments() const {
  // @@protoc_insertion_point(field_list:mz.proto.Graph.comments)
  return comments_;
}

// -------------------------------------------------------------------

// Comment

// string id = 1;
inline void Comment::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& Comment::id() const {
  // @@protoc_insertion_point(field_get:mz.proto.Comment.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Comment::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mz.proto.Comment.id)
}
inline std::string* Comment::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:mz.proto.Comment.id)
  return _s;
}
inline const std::string& Comment::_internal_id() const {
  return id_.Get();
}
inline void Comment::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Comment::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Comment::release_id() {
  // @@protoc_insertion_point(field_release:mz.proto.Comment.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Comment::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mz.proto.Comment.id)
}

// string display_name = 2;
inline void Comment::clear_display_name() {
  display_name_.ClearToEmpty();
}
inline const std::string& Comment::display_name() const {
  // @@protoc_insertion_point(field_get:mz.proto.Comment.display_name)
  return _internal_display_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Comment::set_display_name(ArgT0&& arg0, ArgT... args) {
 
 display_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mz.proto.Comment.display_name)
}
inline std::string* Comment::mutable_display_name() {
  std::string* _s = _internal_mutable_display_name();
  // @@protoc_insertion_point(field_mutable:mz.proto.Comment.display_name)
  return _s;
}
inline const std::string& Comment::_internal_display_name() const {
  return display_name_.Get();
}
inline void Comment::_internal_set_display_name(const std::string& value) {
  
  display_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Comment::_internal_mutable_display_name() {
  
  return display_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Comment::release_display_name() {
  // @@protoc_insertion_point(field_release:mz.proto.Comment.display_name)
  return display_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Comment::set_allocated_display_name(std::string* display_name) {
  if (display_name != nullptr) {
    
  } else {
    
  }
  display_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), display_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (display_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    display_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mz.proto.Comment.display_name)
}

// .mz.proto.vec2i pos = 3;
inline bool Comment::_internal_has_pos() const {
  return this != internal_default_instance() && pos_ != nullptr;
}
inline bool Comment::has_pos() const {
  return _internal_has_pos();
}
inline const ::mz::proto::vec2i& Comment::_internal_pos() const {
  const ::mz::proto::vec2i* p = pos_;
  return p != nullptr ? *p : reinterpret_cast<const ::mz::proto::vec2i&>(
      ::mz::proto::_vec2i_default_instance_);
}
inline const ::mz::proto::vec2i& Comment::pos() const {
  // @@protoc_insertion_point(field_get:mz.proto.Comment.pos)
  return _internal_pos();
}
inline void Comment::unsafe_arena_set_allocated_pos(
    ::mz::proto::vec2i* pos) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pos_);
  }
  pos_ = pos;
  if (pos) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mz.proto.Comment.pos)
}
inline ::mz::proto::vec2i* Comment::release_pos() {
  
  ::mz::proto::vec2i* temp = pos_;
  pos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mz::proto::vec2i* Comment::unsafe_arena_release_pos() {
  // @@protoc_insertion_point(field_release:mz.proto.Comment.pos)
  
  ::mz::proto::vec2i* temp = pos_;
  pos_ = nullptr;
  return temp;
}
inline ::mz::proto::vec2i* Comment::_internal_mutable_pos() {
  
  if (pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::mz::proto::vec2i>(GetArenaForAllocation());
    pos_ = p;
  }
  return pos_;
}
inline ::mz::proto::vec2i* Comment::mutable_pos() {
  ::mz::proto::vec2i* _msg = _internal_mutable_pos();
  // @@protoc_insertion_point(field_mutable:mz.proto.Comment.pos)
  return _msg;
}
inline void Comment::set_allocated_pos(::mz::proto::vec2i* pos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(pos_);
  }
  if (pos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pos));
    if (message_arena != submessage_arena) {
      pos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pos, submessage_arena);
    }
    
  } else {
    
  }
  pos_ = pos;
  // @@protoc_insertion_point(field_set_allocated:mz.proto.Comment.pos)
}

// .mz.proto.vec2i size = 4;
inline bool Comment::_internal_has_size() const {
  return this != internal_default_instance() && size_ != nullptr;
}
inline bool Comment::has_size() const {
  return _internal_has_size();
}
inline const ::mz::proto::vec2i& Comment::_internal_size() const {
  const ::mz::proto::vec2i* p = size_;
  return p != nullptr ? *p : reinterpret_cast<const ::mz::proto::vec2i&>(
      ::mz::proto::_vec2i_default_instance_);
}
inline const ::mz::proto::vec2i& Comment::size() const {
  // @@protoc_insertion_point(field_get:mz.proto.Comment.size)
  return _internal_size();
}
inline void Comment::unsafe_arena_set_allocated_size(
    ::mz::proto::vec2i* size) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(size_);
  }
  size_ = size;
  if (size) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mz.proto.Comment.size)
}
inline ::mz::proto::vec2i* Comment::release_size() {
  
  ::mz::proto::vec2i* temp = size_;
  size_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mz::proto::vec2i* Comment::unsafe_arena_release_size() {
  // @@protoc_insertion_point(field_release:mz.proto.Comment.size)
  
  ::mz::proto::vec2i* temp = size_;
  size_ = nullptr;
  return temp;
}
inline ::mz::proto::vec2i* Comment::_internal_mutable_size() {
  
  if (size_ == nullptr) {
    auto* p = CreateMaybeMessage<::mz::proto::vec2i>(GetArenaForAllocation());
    size_ = p;
  }
  return size_;
}
inline ::mz::proto::vec2i* Comment::mutable_size() {
  ::mz::proto::vec2i* _msg = _internal_mutable_size();
  // @@protoc_insertion_point(field_mutable:mz.proto.Comment.size)
  return _msg;
}
inline void Comment::set_allocated_size(::mz::proto::vec2i* size) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(size_);
  }
  if (size) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(size));
    if (message_arena != submessage_arena) {
      size = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, size, submessage_arena);
    }
    
  } else {
    
  }
  size_ = size;
  // @@protoc_insertion_point(field_set_allocated:mz.proto.Comment.size)
}

// -------------------------------------------------------------------

// Pin

// string id = 1;
inline void Pin::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& Pin::id() const {
  // @@protoc_insertion_point(field_get:mz.proto.Pin.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Pin::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mz.proto.Pin.id)
}
inline std::string* Pin::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:mz.proto.Pin.id)
  return _s;
}
inline const std::string& Pin::_internal_id() const {
  return id_.Get();
}
inline void Pin::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Pin::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Pin::release_id() {
  // @@protoc_insertion_point(field_release:mz.proto.Pin.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Pin::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mz.proto.Pin.id)
}

// string name = 2;
inline void Pin::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Pin::name() const {
  // @@protoc_insertion_point(field_get:mz.proto.Pin.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Pin::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mz.proto.Pin.name)
}
inline std::string* Pin::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:mz.proto.Pin.name)
  return _s;
}
inline const std::string& Pin::_internal_name() const {
  return name_.Get();
}
inline void Pin::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Pin::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Pin::release_name() {
  // @@protoc_insertion_point(field_release:mz.proto.Pin.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Pin::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mz.proto.Pin.name)
}

// string display_name = 3;
inline void Pin::clear_display_name() {
  display_name_.ClearToEmpty();
}
inline const std::string& Pin::display_name() const {
  // @@protoc_insertion_point(field_get:mz.proto.Pin.display_name)
  return _internal_display_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Pin::set_display_name(ArgT0&& arg0, ArgT... args) {
 
 display_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mz.proto.Pin.display_name)
}
inline std::string* Pin::mutable_display_name() {
  std::string* _s = _internal_mutable_display_name();
  // @@protoc_insertion_point(field_mutable:mz.proto.Pin.display_name)
  return _s;
}
inline const std::string& Pin::_internal_display_name() const {
  return display_name_.Get();
}
inline void Pin::_internal_set_display_name(const std::string& value) {
  
  display_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Pin::_internal_mutable_display_name() {
  
  return display_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Pin::release_display_name() {
  // @@protoc_insertion_point(field_release:mz.proto.Pin.display_name)
  return display_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Pin::set_allocated_display_name(std::string* display_name) {
  if (display_name != nullptr) {
    
  } else {
    
  }
  display_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), display_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (display_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    display_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mz.proto.Pin.display_name)
}

// -------------------------------------------------------------------

// Connection

// string from = 1;
inline void Connection::clear_from() {
  from_.ClearToEmpty();
}
inline const std::string& Connection::from() const {
  // @@protoc_insertion_point(field_get:mz.proto.Connection.from)
  return _internal_from();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Connection::set_from(ArgT0&& arg0, ArgT... args) {
 
 from_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mz.proto.Connection.from)
}
inline std::string* Connection::mutable_from() {
  std::string* _s = _internal_mutable_from();
  // @@protoc_insertion_point(field_mutable:mz.proto.Connection.from)
  return _s;
}
inline const std::string& Connection::_internal_from() const {
  return from_.Get();
}
inline void Connection::_internal_set_from(const std::string& value) {
  
  from_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Connection::_internal_mutable_from() {
  
  return from_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Connection::release_from() {
  // @@protoc_insertion_point(field_release:mz.proto.Connection.from)
  return from_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Connection::set_allocated_from(std::string* from) {
  if (from != nullptr) {
    
  } else {
    
  }
  from_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    from_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mz.proto.Connection.from)
}

// string to = 2;
inline void Connection::clear_to() {
  to_.ClearToEmpty();
}
inline const std::string& Connection::to() const {
  // @@protoc_insertion_point(field_get:mz.proto.Connection.to)
  return _internal_to();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Connection::set_to(ArgT0&& arg0, ArgT... args) {
 
 to_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mz.proto.Connection.to)
}
inline std::string* Connection::mutable_to() {
  std::string* _s = _internal_mutable_to();
  // @@protoc_insertion_point(field_mutable:mz.proto.Connection.to)
  return _s;
}
inline const std::string& Connection::_internal_to() const {
  return to_.Get();
}
inline void Connection::_internal_set_to(const std::string& value) {
  
  to_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Connection::_internal_mutable_to() {
  
  return to_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Connection::release_to() {
  // @@protoc_insertion_point(field_release:mz.proto.Connection.to)
  return to_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Connection::set_allocated_to(std::string* to) {
  if (to != nullptr) {
    
  } else {
    
  }
  to_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), to,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (to_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    to_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mz.proto.Connection.to)
}

// string id = 3;
inline void Connection::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& Connection::id() const {
  // @@protoc_insertion_point(field_get:mz.proto.Connection.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Connection::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mz.proto.Connection.id)
}
inline std::string* Connection::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:mz.proto.Connection.id)
  return _s;
}
inline const std::string& Connection::_internal_id() const {
  return id_.Get();
}
inline void Connection::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Connection::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Connection::release_id() {
  // @@protoc_insertion_point(field_release:mz.proto.Connection.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Connection::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mz.proto.Connection.id)
}

// -------------------------------------------------------------------

// Node

// .mz.proto.NodeType type = 1;
inline void Node::clear_type() {
  type_ = 0;
}
inline ::mz::proto::NodeType Node::_internal_type() const {
  return static_cast< ::mz::proto::NodeType >(type_);
}
inline ::mz::proto::NodeType Node::type() const {
  // @@protoc_insertion_point(field_get:mz.proto.Node.type)
  return _internal_type();
}
inline void Node::_internal_set_type(::mz::proto::NodeType value) {
  
  type_ = value;
}
inline void Node::set_type(::mz::proto::NodeType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:mz.proto.Node.type)
}

// string id = 2;
inline void Node::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& Node::id() const {
  // @@protoc_insertion_point(field_get:mz.proto.Node.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Node::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mz.proto.Node.id)
}
inline std::string* Node::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:mz.proto.Node.id)
  return _s;
}
inline const std::string& Node::_internal_id() const {
  return id_.Get();
}
inline void Node::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Node::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Node::release_id() {
  // @@protoc_insertion_point(field_release:mz.proto.Node.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Node::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mz.proto.Node.id)
}

// string class_name = 3;
inline void Node::clear_class_name() {
  class_name_.ClearToEmpty();
}
inline const std::string& Node::class_name() const {
  // @@protoc_insertion_point(field_get:mz.proto.Node.class_name)
  return _internal_class_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Node::set_class_name(ArgT0&& arg0, ArgT... args) {
 
 class_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mz.proto.Node.class_name)
}
inline std::string* Node::mutable_class_name() {
  std::string* _s = _internal_mutable_class_name();
  // @@protoc_insertion_point(field_mutable:mz.proto.Node.class_name)
  return _s;
}
inline const std::string& Node::_internal_class_name() const {
  return class_name_.Get();
}
inline void Node::_internal_set_class_name(const std::string& value) {
  
  class_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Node::_internal_mutable_class_name() {
  
  return class_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Node::release_class_name() {
  // @@protoc_insertion_point(field_release:mz.proto.Node.class_name)
  return class_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Node::set_allocated_class_name(std::string* class_name) {
  if (class_name != nullptr) {
    
  } else {
    
  }
  class_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), class_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (class_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    class_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mz.proto.Node.class_name)
}

// string display_name = 4;
inline void Node::clear_display_name() {
  display_name_.ClearToEmpty();
}
inline const std::string& Node::display_name() const {
  // @@protoc_insertion_point(field_get:mz.proto.Node.display_name)
  return _internal_display_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Node::set_display_name(ArgT0&& arg0, ArgT... args) {
 
 display_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mz.proto.Node.display_name)
}
inline std::string* Node::mutable_display_name() {
  std::string* _s = _internal_mutable_display_name();
  // @@protoc_insertion_point(field_mutable:mz.proto.Node.display_name)
  return _s;
}
inline const std::string& Node::_internal_display_name() const {
  return display_name_.Get();
}
inline void Node::_internal_set_display_name(const std::string& value) {
  
  display_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Node::_internal_mutable_display_name() {
  
  return display_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Node::release_display_name() {
  // @@protoc_insertion_point(field_release:mz.proto.Node.display_name)
  return display_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Node::set_allocated_display_name(std::string* display_name) {
  if (display_name != nullptr) {
    
  } else {
    
  }
  display_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), display_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (display_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    display_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mz.proto.Node.display_name)
}

// repeated .mz.proto.Pin pins = 5;
inline int Node::_internal_pins_size() const {
  return pins_.size();
}
inline int Node::pins_size() const {
  return _internal_pins_size();
}
inline void Node::clear_pins() {
  pins_.Clear();
}
inline ::mz::proto::Pin* Node::mutable_pins(int index) {
  // @@protoc_insertion_point(field_mutable:mz.proto.Node.pins)
  return pins_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mz::proto::Pin >*
Node::mutable_pins() {
  // @@protoc_insertion_point(field_mutable_list:mz.proto.Node.pins)
  return &pins_;
}
inline const ::mz::proto::Pin& Node::_internal_pins(int index) const {
  return pins_.Get(index);
}
inline const ::mz::proto::Pin& Node::pins(int index) const {
  // @@protoc_insertion_point(field_get:mz.proto.Node.pins)
  return _internal_pins(index);
}
inline ::mz::proto::Pin* Node::_internal_add_pins() {
  return pins_.Add();
}
inline ::mz::proto::Pin* Node::add_pins() {
  ::mz::proto::Pin* _add = _internal_add_pins();
  // @@protoc_insertion_point(field_add:mz.proto.Node.pins)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mz::proto::Pin >&
Node::pins() const {
  // @@protoc_insertion_point(field_list:mz.proto.Node.pins)
  return pins_;
}

// .mz.proto.vec2i pos = 6;
inline bool Node::_internal_has_pos() const {
  return this != internal_default_instance() && pos_ != nullptr;
}
inline bool Node::has_pos() const {
  return _internal_has_pos();
}
inline const ::mz::proto::vec2i& Node::_internal_pos() const {
  const ::mz::proto::vec2i* p = pos_;
  return p != nullptr ? *p : reinterpret_cast<const ::mz::proto::vec2i&>(
      ::mz::proto::_vec2i_default_instance_);
}
inline const ::mz::proto::vec2i& Node::pos() const {
  // @@protoc_insertion_point(field_get:mz.proto.Node.pos)
  return _internal_pos();
}
inline void Node::unsafe_arena_set_allocated_pos(
    ::mz::proto::vec2i* pos) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pos_);
  }
  pos_ = pos;
  if (pos) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mz.proto.Node.pos)
}
inline ::mz::proto::vec2i* Node::release_pos() {
  
  ::mz::proto::vec2i* temp = pos_;
  pos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mz::proto::vec2i* Node::unsafe_arena_release_pos() {
  // @@protoc_insertion_point(field_release:mz.proto.Node.pos)
  
  ::mz::proto::vec2i* temp = pos_;
  pos_ = nullptr;
  return temp;
}
inline ::mz::proto::vec2i* Node::_internal_mutable_pos() {
  
  if (pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::mz::proto::vec2i>(GetArenaForAllocation());
    pos_ = p;
  }
  return pos_;
}
inline ::mz::proto::vec2i* Node::mutable_pos() {
  ::mz::proto::vec2i* _msg = _internal_mutable_pos();
  // @@protoc_insertion_point(field_mutable:mz.proto.Node.pos)
  return _msg;
}
inline void Node::set_allocated_pos(::mz::proto::vec2i* pos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(pos_);
  }
  if (pos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pos));
    if (message_arena != submessage_arena) {
      pos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pos, submessage_arena);
    }
    
  } else {
    
  }
  pos_ = pos;
  // @@protoc_insertion_point(field_set_allocated:mz.proto.Node.pos)
}

// .mz.proto.Job job = 7;
inline bool Node::_internal_has_job() const {
  return contents_case() == kJob;
}
inline bool Node::has_job() const {
  return _internal_has_job();
}
inline void Node::set_has_job() {
  _oneof_case_[0] = kJob;
}
inline void Node::clear_job() {
  if (_internal_has_job()) {
    if (GetArenaForAllocation() == nullptr) {
      delete contents_.job_;
    }
    clear_has_contents();
  }
}
inline ::mz::proto::Job* Node::release_job() {
  // @@protoc_insertion_point(field_release:mz.proto.Node.job)
  if (_internal_has_job()) {
    clear_has_contents();
      ::mz::proto::Job* temp = contents_.job_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    contents_.job_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mz::proto::Job& Node::_internal_job() const {
  return _internal_has_job()
      ? *contents_.job_
      : reinterpret_cast< ::mz::proto::Job&>(::mz::proto::_Job_default_instance_);
}
inline const ::mz::proto::Job& Node::job() const {
  // @@protoc_insertion_point(field_get:mz.proto.Node.job)
  return _internal_job();
}
inline ::mz::proto::Job* Node::unsafe_arena_release_job() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mz.proto.Node.job)
  if (_internal_has_job()) {
    clear_has_contents();
    ::mz::proto::Job* temp = contents_.job_;
    contents_.job_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Node::unsafe_arena_set_allocated_job(::mz::proto::Job* job) {
  clear_contents();
  if (job) {
    set_has_job();
    contents_.job_ = job;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mz.proto.Node.job)
}
inline ::mz::proto::Job* Node::_internal_mutable_job() {
  if (!_internal_has_job()) {
    clear_contents();
    set_has_job();
    contents_.job_ = CreateMaybeMessage< ::mz::proto::Job >(GetArenaForAllocation());
  }
  return contents_.job_;
}
inline ::mz::proto::Job* Node::mutable_job() {
  ::mz::proto::Job* _msg = _internal_mutable_job();
  // @@protoc_insertion_point(field_mutable:mz.proto.Node.job)
  return _msg;
}

// .mz.proto.Graph graph = 8;
inline bool Node::_internal_has_graph() const {
  return contents_case() == kGraph;
}
inline bool Node::has_graph() const {
  return _internal_has_graph();
}
inline void Node::set_has_graph() {
  _oneof_case_[0] = kGraph;
}
inline void Node::clear_graph() {
  if (_internal_has_graph()) {
    if (GetArenaForAllocation() == nullptr) {
      delete contents_.graph_;
    }
    clear_has_contents();
  }
}
inline ::mz::proto::Graph* Node::release_graph() {
  // @@protoc_insertion_point(field_release:mz.proto.Node.graph)
  if (_internal_has_graph()) {
    clear_has_contents();
      ::mz::proto::Graph* temp = contents_.graph_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    contents_.graph_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mz::proto::Graph& Node::_internal_graph() const {
  return _internal_has_graph()
      ? *contents_.graph_
      : reinterpret_cast< ::mz::proto::Graph&>(::mz::proto::_Graph_default_instance_);
}
inline const ::mz::proto::Graph& Node::graph() const {
  // @@protoc_insertion_point(field_get:mz.proto.Node.graph)
  return _internal_graph();
}
inline ::mz::proto::Graph* Node::unsafe_arena_release_graph() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mz.proto.Node.graph)
  if (_internal_has_graph()) {
    clear_has_contents();
    ::mz::proto::Graph* temp = contents_.graph_;
    contents_.graph_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Node::unsafe_arena_set_allocated_graph(::mz::proto::Graph* graph) {
  clear_contents();
  if (graph) {
    set_has_graph();
    contents_.graph_ = graph;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mz.proto.Node.graph)
}
inline ::mz::proto::Graph* Node::_internal_mutable_graph() {
  if (!_internal_has_graph()) {
    clear_contents();
    set_has_graph();
    contents_.graph_ = CreateMaybeMessage< ::mz::proto::Graph >(GetArenaForAllocation());
  }
  return contents_.graph_;
}
inline ::mz::proto::Graph* Node::mutable_graph() {
  ::mz::proto::Graph* _msg = _internal_mutable_graph();
  // @@protoc_insertion_point(field_mutable:mz.proto.Node.graph)
  return _msg;
}

inline bool Node::has_contents() const {
  return contents_case() != CONTENTS_NOT_SET;
}
inline void Node::clear_has_contents() {
  _oneof_case_[0] = CONTENTS_NOT_SET;
}
inline Node::ContentsCase Node::contents_case() const {
  return Node::ContentsCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace mz

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::mz::proto::JobType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mz::proto::JobType>() {
  return ::mz::proto::JobType_descriptor();
}
template <> struct is_proto_enum< ::mz::proto::NodeType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mz::proto::NodeType>() {
  return ::mz::proto::NodeType_descriptor();
}
template <> struct is_proto_enum< ::mz::proto::ShowAs> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mz::proto::ShowAs>() {
  return ::mz::proto::ShowAs_descriptor();
}
template <> struct is_proto_enum< ::mz::proto::CanShowAs> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mz::proto::CanShowAs>() {
  return ::mz::proto::CanShowAs_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_ProtoCommon_2eproto
